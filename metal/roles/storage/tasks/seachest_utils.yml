---
# Seagate-specific health checks using seachest utilities

- name: Ensure dependencies
  package:
    name:
      - lsscsi

- name: Check seachest_SMART availability
  command: which seachest_SMART
  register: seachest_check
  failed_when: false
  changed_when: false

- name: Fail if seachest not available when prefer_native_utils is true
  fail:
    msg: "prefer_native_utils=true but seachest_SMART not found for Seagate drives. Please install seachest-utils or set prefer_native_utils=false"
  when: seachest_check.rc != 0

- name: Convert by-id paths to sg device paths for seachest
  shell: |
    set -e
    set -o pipefail
    DEVICE="{{ item }}"
    # Get the real device name
    REAL_DEV=$(readlink -f "$DEVICE" | sed 's|/dev/||')
    # Find the corresponding sg device
    SG_DEV=$(lsscsi -g | grep "$REAL_DEV" | awk '{print $NF}')
    echo "$SG_DEV"
  loop: "{{ seagate_device_paths }}"
  register: sg_device_conversion
  changed_when: false
  failed_when: sg_device_conversion.rc != 0

- name: Run seachest SMART health checks
  command: "seachest_SMART -d {{ item.stdout }} --smartAttributes hybrid"
  loop: "{{ sg_device_conversion.results }}"
  register: seachest_results
  failed_when: false
  changed_when: false

- name: Parse seachest output
  set_fact:
    disk_health_report: "{{ disk_health_report + [parsed_entry] }}"
  loop: "{{ seachest_results.results }}"
  loop_control:
    extended: true
  when: item.rc == 0
  vars:
    # Parse the seachest output format (text-based)
    # Extract critical attributes from the output
    output_lines: "{{ item.stdout_lines }}"
    device_line: "{{ output_lines | select('match', '^/dev/sg.*') | first | default('') }}"
    temp_line: "{{ output_lines | select('search', 'Temperature') | select('search', '194') | first | default('') }}"
    reallocated_line: "{{ output_lines | select('search', 'Retired Sectors Count') | select('search', '5') | first | default('') }}"
    pending_line: "{{ output_lines | select('search', 'Pending-Sparing Count') | select('search', '197') | first | default('') }}"
    uncorrectable_line: "{{ output_lines | select('search', 'Reported Un-correctable') | select('search', '187') | first | default('') }}"
    power_hours_line: "{{ output_lines | select('search', 'Power On Hours') | select('search', '9') | first | default('') }}"

    # Extract raw values (these patterns match the output format shown in smart.out)
    # Format: "? 194 Temperature -O---K 30 58 AP 30 (m/M 18/58)"
    # We want the first numeric value after the flags
    temp_value: "{{ temp_line | regex_search('\\s+(\\d+)\\s+\\d+\\s+\\w+\\s+(\\d+)', '\\2') | first | default(-1) | int }}"
    reallocated_value: "{{ reallocated_line | regex_search('\\s+\\d+\\s+\\d+\\s+\\d+\\s+(\\d+)', '\\1') | first | default(0) | int }}"
    pending_value: "{{ pending_line | regex_search('\\s+\\d+\\s+\\d+\\s+\\w+\\s+(\\d+)', '\\1') | first | default(0) | int }}"
    uncorrectable_value: "{{ uncorrectable_line | regex_search('\\s+\\d+\\s+\\d+\\s+\\w+\\s+(\\d+)', '\\1') | first | default(0) | int }}"
    power_hours_value: "{{ power_hours_line | regex_search('\\s+\\d+\\s+\\d+\\s+\\w+\\s+(\\d+)', '\\1') | first | default('N/A') }}"

    # Overall health - check if no attributes are marked with ! (currently failing)
    has_failures: "{{ output_lines | select('search', '^!') | list | length > 0 }}"

    parsed_entry:
      device: "{{ seagate_device_paths[ansible_loop.index0] }}"
      sg_device: "{{ item.item.stdout }}"
      tool: "seachest"
      overall_health: "{{ not has_failures }}"
      temperature: "{{ temp_value }}"
      reallocated_sectors: "{{ reallocated_value }}"
      pending_sectors: "{{ pending_value }}"
      uncorrectable_errors: "{{ uncorrectable_value }}"
      power_on_hours: "{{ power_hours_value }}"
      model: "{{ (output_lines | select('match', '^/dev/sg.*') | first | default('')).split('-')[1] | default('Unknown') }}"
      serial: "{{ (output_lines | select('match', '^/dev/sg.*') | first | default('')).split('-')[2] | default('Unknown') }}"
